package toptal.test.project.remote.common

import io.reactivex.Completable
import io.reactivex.Flowable
import io.reactivex.Maybe
import io.reactivex.Observable
import io.reactivex.Single
import okhttp3.Response
import retrofit2.Call
import retrofit2.CallAdapter
import retrofit2.HttpException
import toptal.test.project.exceptions.ClientError
import toptal.test.project.exceptions.NoConnectionError
import toptal.test.project.exceptions.ServerError
import toptal.test.project.exceptions.UnknownNetworkError
import java.lang.reflect.Type
import java.net.UnknownHostException

internal class AQRxJava2CallAdapter<R>(
    private val wrappedAdapter: CallAdapter<R, Any>
) : CallAdapter<R, Any> {

    override fun adapt(call: Call<R>): Any {
        return with(wrappedAdapter.adapt(call)) {
            when (this) {
                is Observable<*> -> onErrorResumeNext { throwable: Throwable ->
                    Observable.error(throwable.toNetworkException())
                }
                is Single<*> -> onErrorResumeNext { throwable: Throwable ->
                    Single.error(throwable.toNetworkException())
                }
                is Flowable<*> -> onErrorResumeNext { throwable: Throwable ->
                    Flowable.error(throwable.toNetworkException())
                }
                is Maybe<*> -> onErrorResumeNext { throwable: Throwable ->
                    Maybe.error(throwable.toNetworkException())
                }
                is Completable -> onErrorResumeNext { throwable: Throwable ->
                    Completable.error(throwable.toNetworkException())
                }
                else -> throw IllegalArgumentException("$javaClass type is not supported")
            }
        }
    }

    override fun responseType(): Type = wrappedAdapter.responseType()

    /**
     * Converts a Throwable to NetworkException, if it is generated by HttpException or other
     * network error event (for instance, no network)
     */
    private fun Throwable.toNetworkException(): Throwable {
        return parse { code, response ->
            when (code) {
                // 4xx Client Error
                400 -> ClientError.BadRequest(response)
                401 -> ClientError.Unauthorized(response)
                402 -> ClientError.PaymentRequired(response)
                403 -> ClientError.Forbidden(response)
                404 -> ClientError.NotFound(response)
                405 -> ClientError.MethodNotAllowed(response)
                406 -> ClientError.NotAcceptable(response)
                407 -> ClientError.ProxyAuthenticationRequired(response)
                408 -> ClientError.RequestTimeout(response)
                409 -> ClientError.Conflict(response)
                410 -> ClientError.Gone(response)
                411 -> ClientError.LengthRequired(response)
                412 -> ClientError.PreconditionFailed(response)
                413 -> ClientError.RequestEntityTooLarge(response)
                414 -> ClientError.RequestUriTooLong(response)
                415 -> ClientError.UnsupportedMediaType(response)
                416 -> ClientError.RequestedRangeNotSatisfiable(response)
                417 -> ClientError.ExpectationFailed(response)
                422 -> ClientError.ValidationFailed(response)

                // 5xx ServClientError.er Error
                500 -> ServerError.InternalServerError(response)
                501 -> ServerError.NotImplemented(response)
                502 -> ServerError.BadGateway(response)
                503 -> ServerError.ServiceUnavailable(response)
                504 -> ServerError.GatewayTimeOut(response)
                505 -> ServerError.HttpVersionNotSupported(response)

                // Unknown error type
                else -> UnknownNetworkError(response)
            }
        }.let {
            // Some exceptions are not HttpExceptions, cover them in here as well
            when (it) {
                is UnknownHostException -> NoConnectionError(it.message ?: "")
                else -> it
            }
        }
    }

    /**
     * Parses the provided [Throwable] into another exception applying the provided converter logic
     */
    private inline fun Throwable.parse(converter: (Int, Response?) -> Exception): Throwable {
        return (this as? HttpException)?.let { converter(code(), response()?.raw()) } ?: this
    }

}
